use crate::core::{LpmError, LpmResult};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    #[serde(default = "default_lockfile_version")]
    pub version: u32,
    pub generated_at: DateTime<Utc>,
    #[serde(default)]
    pub packages: HashMap<String, LockedPackage>,
}

fn default_lockfile_version() -> u32 {
    1
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    pub version: String,
    pub source: String,
    #[serde(default)]
    pub rockspec_url: Option<String>,
    #[serde(default)]
    pub source_url: Option<String>,
    pub checksum: String,
    #[serde(default)]
    pub size: Option<u64>,
    #[serde(default)]
    pub dependencies: HashMap<String, String>,
    #[serde(default)]
    pub build: Option<LockedBuild>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedBuild {
    #[serde(rename = "type")]
    pub build_type: String,
    pub target: String,
    pub built_at: DateTime<Utc>,
    #[serde(default)]
    pub installed_files: Vec<String>,
}

impl Lockfile {
    /// Load package.lock from a directory
    pub fn load(dir: &Path) -> LpmResult<Option<Self>> {
        let path = dir.join("package.lock");
        if !path.exists() {
            return Ok(None);
        }

        let content = fs::read_to_string(&path)?;
        let lockfile: Lockfile = serde_yaml::from_str(&content)
            .map_err(|e| LpmError::Package(format!("Failed to parse package.lock: {}", e)))?;

        Ok(Some(lockfile))
    }

    /// Save package.lock to a directory
    pub fn save(&self, dir: &Path) -> LpmResult<()> {
        let path = dir.join("package.lock");
        
        // Add header comment
        let mut content = String::from("# DO NOT EDIT - Generated by LPM\n");
        let yaml = serde_yaml::to_string(self)
            .map_err(|e| LpmError::Package(format!("Failed to serialize package.lock: {}", e)))?;
        content.push_str(&yaml);

        fs::write(&path, content)?;
        Ok(())
    }

    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            generated_at: Utc::now(),
            packages: HashMap::new(),
        }
    }

    /// Add a package to the lockfile
    pub fn add_package(&mut self, name: String, package: LockedPackage) {
        self.packages.insert(name, package);
    }

    /// Get a package from the lockfile
    pub fn get_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.get(name)
    }

    /// Check if a package is in the lockfile
    pub fn has_package(&self, name: &str) -> bool {
        self.packages.contains_key(name)
    }
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_lockfile_new() {
        let lockfile = Lockfile::new();
        assert_eq!(lockfile.version, 1);
        assert!(lockfile.packages.is_empty());
    }

    #[test]
    fn test_lockfile_add_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: Some("https://example.com/test-1.0.0.rockspec".to_string()),
            source_url: Some("https://example.com/test-1.0.0.tar.gz".to_string()),
            checksum: "abc123".to_string(),
            size: Some(1024),
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        
        lockfile.add_package("test-package".to_string(), package);
        assert!(lockfile.has_package("test-package"));
    }

    #[test]
    fn test_lockfile_get_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        
        lockfile.add_package("test-package".to_string(), package.clone());
        let retrieved = lockfile.get_package("test-package");
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap().version, "1.0.0");
    }

    #[test]
    fn test_lockfile_has_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        
        assert!(!lockfile.has_package("test-package"));
        lockfile.add_package("test-package".to_string(), package);
        assert!(lockfile.has_package("test-package"));
    }

    #[test]
    fn test_lockfile_save_and_load() {
        let temp = TempDir::new().unwrap();
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: Some("https://example.com/test-1.0.0.rockspec".to_string()),
            source_url: Some("https://example.com/test-1.0.0.tar.gz".to_string()),
            checksum: "abc123".to_string(),
            size: Some(1024),
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        
        lockfile.add_package("test-package".to_string(), package);
        lockfile.save(temp.path()).unwrap();
        
        let loaded = Lockfile::load(temp.path()).unwrap().unwrap();
        assert_eq!(loaded.version, 1);
        assert!(loaded.has_package("test-package"));
        let loaded_pkg = loaded.get_package("test-package").unwrap();
        assert_eq!(loaded_pkg.version, "1.0.0");
        assert_eq!(loaded_pkg.checksum, "abc123");
    }

    #[test]
    fn test_lockfile_load_nonexistent() {
        let temp = TempDir::new().unwrap();
        let result = Lockfile::load(temp.path()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_locked_package_with_dependencies() {
        let mut dependencies = std::collections::HashMap::new();
        dependencies.insert("dep1".to_string(), "1.0.0".to_string());
        dependencies.insert("dep2".to_string(), "2.0.0".to_string());
        
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies,
            build: None,
        };
        
        assert_eq!(package.dependencies.len(), 2);
        assert_eq!(package.dependencies.get("dep1"), Some(&"1.0.0".to_string()));
    }

    #[test]
    fn test_locked_package_with_build() {
        let build = LockedBuild {
            build_type: "rust".to_string(),
            target: "x86_64-unknown-linux-gnu".to_string(),
            built_at: chrono::Utc::now(),
            installed_files: vec!["lib.so".to_string()],
        };
        
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: Some(build),
        };
        
        assert!(package.build.is_some());
        assert_eq!(package.build.as_ref().unwrap().build_type, "rust");
    }
}

