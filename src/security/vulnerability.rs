use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Severity level of a security vulnerability
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize, Hash)]
pub enum Severity {
    /// Low severity - minor issue, unlikely to be exploited
    Low,
    /// Medium severity - moderate risk, should be addressed
    Medium,
    /// High severity - significant risk, should be fixed soon
    High,
    /// Critical severity - immediate action required
    Critical,
}

impl Severity {
    pub fn as_str(&self) -> &'static str {
        match self {
            Severity::Low => "Low",
            Severity::Medium => "Medium",
            Severity::High => "High",
            Severity::Critical => "Critical",
        }
    }

    pub fn emoji(&self) -> &'static str {
        match self {
            Severity::Low => "â„¹ï¸",
            Severity::Medium => "âš ï¸",
            Severity::High => "ðŸ”´",
            Severity::Critical => "ðŸš¨",
        }
    }
}

/// A security vulnerability affecting a package
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Package name
    pub package: String,
    /// Affected version range (e.g., "<3.0.0")
    pub affected_versions: String,
    /// Vulnerability severity
    pub severity: Severity,
    /// CVE identifier (if available)
    pub cve: Option<String>,
    /// Advisory title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Fixed in version (if available)
    pub fixed_in: Option<String>,
    /// References/links
    pub references: Vec<String>,
}

impl Vulnerability {
    /// Check if a version is affected by this vulnerability
    pub fn affects_version(&self, version: &str) -> bool {
        use crate::core::version::{parse_constraint, Version};

        // Parse the affected_versions constraint
        if let Ok(constraint) = parse_constraint(&self.affected_versions) {
            if let Ok(v) = Version::parse(version) {
                return v.satisfies(&constraint);
            }
        }

        // Fallback: simple string matching for common patterns
        if self.affected_versions.starts_with("<") {
            if let (Ok(affected), Ok(check)) = (
                Version::parse(&self.affected_versions[1..]),
                Version::parse(version),
            ) {
                return check < affected;
            }
        }

        false
    }
}

/// Collection of vulnerabilities for reporting
#[derive(Debug, Clone, Default)]
pub struct VulnerabilityReport {
    pub vulnerabilities: Vec<Vulnerability>,
    pub package_count: usize,
    pub checked_packages: usize,
}

impl VulnerabilityReport {
    pub fn new() -> Self {
        Self {
            vulnerabilities: Vec::new(),
            package_count: 0,
            checked_packages: 0,
        }
    }

    pub fn add(&mut self, vuln: Vulnerability) {
        self.vulnerabilities.push(vuln);
    }

    pub fn is_empty(&self) -> bool {
        self.vulnerabilities.is_empty()
    }

    pub fn count_by_severity(&self) -> HashMap<Severity, usize> {
        let mut counts = HashMap::new();
        for vuln in &self.vulnerabilities {
            *counts.entry(vuln.severity).or_insert(0) += 1;
        }
        counts
    }

    pub fn has_critical(&self) -> bool {
        self.vulnerabilities
            .iter()
            .any(|v| v.severity == Severity::Critical)
    }

    pub fn has_high(&self) -> bool {
        self.vulnerabilities
            .iter()
            .any(|v| v.severity == Severity::High)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }

    #[test]
    fn test_vulnerability_affects_version() {
        let vuln = Vulnerability {
            package: "test".to_string(),
            affected_versions: "<3.0.0".to_string(),
            severity: Severity::High,
            cve: None,
            title: "Test".to_string(),
            description: "Test".to_string(),
            fixed_in: Some("3.0.0".to_string()),
            references: Vec::new(),
        };

        assert!(vuln.affects_version("2.9.0"));
        assert!(!vuln.affects_version("3.0.0"));
    }
}
